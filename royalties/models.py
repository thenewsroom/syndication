"""
Scenarios to be handled manually:
* Royalty entered after the corresponding RoyaltyStatement was delivered

change royalty_due_date to royalty_statement_due_date
"""
from dateutil.relativedelta import relativedelta

from django.core.urlresolvers import reverse
from django.db import models, IntegrityError
from django.db.models import Sum

from accounts.models import Account, Agreement
from publications.models import Publication

# Create your models here.

CURRENCY = (
    ('USD', 'US Dollars'),
    ('GBP', 'Pounds'),
    ('EUR', 'Euros'),
    ('INR', 'Indian Ruppee'),
)


class Receivable(models.Model):
    """
    capture the receivables - from the royalty statements of the buyers
    """
    title = models.CharField(max_length=255,
                             help_text="For Monthly statements enter Mon, YYYY; For Quarterly statements enter Mon1 - Mon2, YYYY ")
    received_from = models.ForeignKey(Account, limit_choices_to={'type': 'B'})
    revenue = models.DecimalField(max_digits=12, decimal_places=2)
    exchange_rate = models.DecimalField(max_digits=5, decimal_places=2)
    duration_start = models.DateField()
    duration_end = models.DateField()
    received_on = models.DateField()
    currency = models.CharField(max_length=3, choices=CURRENCY)

    class Meta:
        ordering = ('title',)
        unique_together = (('received_from', 'duration_start',),)

    def __unicode__(self):
        return u'%s, %s (%s)' % (self.received_from, self.title,
                                 self.received_on.strftime('%d-%b-%Y'))

    def unallocated(self):
        # get all the payable revenue and see if it adds up
        allocated = Payable.objects.filter(
            receivable=self).aggregate(Sum('revenue'))

        # subtract the allocated amount from revenue, if it exists
        if allocated['revenue__sum']:
            return self.revenue - allocated['revenue__sum']

        # if there are no payables added, just return the revenue
        return self.revenue

    def get_absolute_url(self):
        return reverse('royalties.views.receivable_detail', args=[self.id])


class RoyaltyManager(models.Manager):
    def user_royalties(self, user):
        """
        get the list of Royalties that the user can see,
        staff users have access to everything, others only to their accounts
        """
        royalties = Royalty.objects.none()
        if user.is_superuser:
            royalties = Royalty.objects.all()
        else:
            # a customer! let's get his / her account from the profile
            try:
                royalties = Royalty.objects.filter(
                    account=user.get_profile().account)
            except:
                # not a customer! - cannot give out these details
                pass
        return royalties


class Royalty(models.Model):
    """
    Royalty Statements generated by Contify
    """
    account = models.ForeignKey(Account)
    revenue = models.DecimalField(max_digits=12, decimal_places=2)
    adjustment = models.DecimalField(max_digits=10, decimal_places=2)
    billing_frequency = models.CharField(max_length=1, choices=(('M', 'Monthly'), ('Q', 'Quarterly')))
    statement_date = models.DateField()
    created_on = models.DateTimeField(auto_now_add=True)
    updated_on = models.DateTimeField(auto_now=True)
    deliver = models.BooleanField(default=False)
    delivered_on = models.DateField(null=True, blank=True)
    notes = models.TextField(null=True, blank=True,
                             help_text="This will appear as a paragraph in the invoice below the details")
    objects = RoyaltyManager()

    class Meta:
        ordering = ('created_on',)
        unique_together = ('account', 'statement_date',)
        verbose_name_plural = 'Royalties'

    def __unicode__(self):
        return u'Royalty Statement - %s (%s)' % (self.account, self.get_statement_duration())

    def update_revenue(self):
        """
        get the revenue from each payable associated with this Royalty and aggregate it
        if the Royalty has been delivered - nothing will be updated!
        """
        if not self.delivered_on:
            # get the list of all payables associated with this Royalty and sum it up
            revenue_qs = Payable.objects.filter(
                royalty_statement=self).aggregate(Sum('payable'))
            if revenue_qs['payable__sum']:
                self.revenue = str(revenue_qs['payable__sum'])
            else:
                self.revenue = str(0.0)

    def get_payables(self, user=None):
        if user:
            return Payable.objects.user_payables(user).filter(
                royalty_statement=self).select_related()
        else:
            return Payable.objects.filter(
                royalty_statement=self).select_related()

    def get_statement_duration(self):
        """The last month or quarter calculated from the statement date"""

        if self.billing_frequency == 'M':
            return (self.statement_date - relativedelta(months=1)).strftime('%b, %Y')
        else:
            return '%s - %s' % (
                (self.statement_date - relativedelta(months=3)).strftime('%b'),
                (self.statement_date - relativedelta(months=1)).strftime('%b, %Y')
            )

    def get_absolute_url(self):
        return reverse('royalties.views.royalty_statement_detail', args=[self.id])

    def amount_payable(self):
        return self.revenue - self.adjustment

    def get_sent_to(self):
        return self.account.client_poc

    def get_sent_to_street_address(self):
        return self.account.client_add_line1

    def get_sent_to_city_state(self):
        return self.account.client_add_line2

    def get_sent_to_country(self):
        return self.account.client_country

    def get_sent_to_email(self):
        return self.account.client_email

    def save(self, *args, **kwargs):
        # see if the billing frequency was populated, else pick it up from
        # the current valid agreement
        if not self.billing_frequency:
            self.billing_frequency = self.account.get_agreement().billing_frequency
        super(Royalty, self).save(*args, **kwargs)


class PayableManager(models.Manager):
    def user_payables(self, user):
        """
        get the list of Payables that the user can see,
        staff users have access to everything, others only to their accounts
        """
        payables = Payable.objects.none()
        if user.is_superuser:
            payables = Payable.objects.all()
        else:
            # a customer! let's get his / her account from the profile
            try:
                payables = Payable.objects.filter(
                    account=user.get_profile().account)
            except:
                # not a customer! - cannot give out these details
                pass
        return payables


class Payable(models.Model):
    """
    capture the royalty received for each publication
    """
    receivable = models.ForeignKey(Receivable)
    royalty_statement = models.ForeignKey(Royalty, null=True, blank=True)
    account = models.ForeignKey(Account)
    publication = models.ForeignKey(Publication)
    revenue = models.DecimalField(max_digits=8, decimal_places=2)
    revenue_share = models.PositiveIntegerField()
    override_share = models.PositiveIntegerField(blank=True, null=True)
    payable = models.DecimalField(max_digits=12, decimal_places=2)
    tds_rate = models.DecimalField(max_digits=5, decimal_places=2,
                                   help_text="in percentage (%)")
    objects = PayableManager()

    # ALTER TABLE "royalties_payable" ADD COLUMN "exchange_rate" numeric(5, 2);
    exchange_rate = models.DecimalField(max_digits=5, decimal_places=2, blank=True, null=True)

    class Meta:
        # ordering = ('account__title', )
        unique_together = (('publication', 'receivable', 'royalty_statement',),)

    def __unicode__(self):
        return u'%s (%d)' % (self.publication, self.payable)

    def get_agreement(self):
        return self.publication.account.get_agreement(
            self.receivable.duration_start)

    def get_billing_frequency(self):
        billing_frequency = 'M'
        agreement = self.get_agreement()
        if agreement:
            billing_frequency = agreement.billing_frequency
        return billing_frequency

    def get_exchange_rate(self):
        """
        It is possible that the exchange rate for the Payable may not be the
        same as that of the receivable, at times we have to process payments
        before the actual Receivable is received! To handle this scenario
        field exchange_rate has been added that can be manually updated / modified
        by the admin
        """
        if not self.exchange_rate:
            return self.receivable.exchange_rate
        return self.exchange_rate

    def get_tds_rate(self):
        """
        Gets the TDS rate for the Publication as per the Agreement

        There can be multiple agreements for a Publication, we need to find the
        one that was active when the Roylty Statement was generated
        In short: Royalty Duration start date should lie between agreement
        Signed on and Expires On dates
        """
        # get the TDS rate from the agreement, if it exists
        agreement = self.get_agreement()
        if agreement:
            return agreement.tds_rate
        # if all fails - go for the safest option - 0%
        return 0

    def get_net_payable(self):
        """
        Gets net payable w.r.t payable and TDS rate
        """
        return self.payable - self.payable * self.tds_rate / 100

    def calculate_revenue_share(self):
        """
        Gets the revenue share for the Publication as per the Agreement

        There can be multiple agreements for a Publication, we need to find the
        one that was active when the Roylty Statement was generated
        In short: Royalty Duration start date should lie between agreement
        Signed on and Expires On dates
        """
        if self.override_share:
            return self.override_share

        # get the revenue share from the agreement, if it exists
        agreement = self.get_agreement()
        if agreement:
            return agreement.revenue_share

        # if all fails - go for the safest option - 0%
        return 0

    def calculate_royalty_due_date(self):
        """
        check from the Agreement if payment is monthly or quarterly
        royalty has to be generated in the current month / quarter
        due date will be 15th of the next month or quarter
        """
        received_on = self.receivable.received_on

        due_date = received_on
        if (self.get_billing_frequency() == 'Q'):
            # find the last month of the current quarter
            billing_month = 3 * (1 + (received_on.month - 1) / 3)
            due_date = received_on.replace(day=1, month=billing_month)

        # due date is the 15th of the next month / quarter
        return due_date.replace(day=15) + relativedelta(months=+1)

    def get_royalty_statement(self):
        try:
            royalty_statement, created = Royalty.objects.get_or_create(
                account=self.account,
                statement_date=self.calculate_royalty_due_date(),
                delivered_on__isnull=True,
                billing_frequency=self.get_billing_frequency(),
                defaults={'revenue': str(0.0), 'adjustment': str(0.0)}
            )

            return royalty_statement
        except IntegrityError, e:
            # looks like the corresponding RoyaltyStatement was already
            # delivered ... this one has to be handled manually
            pass
        return None

    def save(self):
        """
        calculate the amount payable in INR
        """
        # get the account and revenue share details
        self.account = self.publication.account
        self.revenue_share = self.calculate_revenue_share()
        self.tds_rate = self.get_tds_rate()

        # check if the exchange rate has been set for the Payable
        # else use the one defined in the Receivable
        if not self.exchange_rate:
            self.exchange_rate = self.receivable.exchange_rate

        # get the exchange rate from Royalty Statement
        # xrate = self.receivable.exchange_rate

        # calculate the payable!
        self.payable = self.exchange_rate * self.revenue * self.revenue_share / 100

        # get the royalty statement for this account and royalty_due_date
        # update if the statement exists
        # ensure that we do not overwrite the existing statement if any with None!
        # if the statement has changed - update it (possible revenue date was updated)
        statement = self.get_royalty_statement()

        if statement:
            # update the royalty_statement
            if not self.royalty_statement or not self.royalty_statement == statement:
                self.royalty_statement = statement

        super(Payable, self).save()

        # the Payable has been modified, lets update the Royalty Statement
        # this should ideally be done via signals - guess was feeling a bit lazy
        if self.royalty_statement:  # and not new_payable:
            self.royalty_statement.update_revenue()
            self.royalty_statement.save()

